import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import api from '../storiesAPI';

const { getTopStories } = api;

export interface TopStoriesState {
    stories: Array<number>;
    status: 'idle' | 'loading' | 'failed' | 'succeeded';
    error: string;
};

const initialState: TopStoriesState = {
    stories: [],
    status: 'idle',
    error: '',
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(loadTopStories(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const getTopStoriesAsync = createAsyncThunk(
    'story/topStories',
    async (noOfStories: number) => {
      const response = await getTopStories(noOfStories);

      if (response.error) {
          return response.error;
      }
      // The value we return becomes the `fulfilled` action payload
      return response.topStories || [];
    }
);

export const topStoriesSlice = createSlice({
    name: 'topStories',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {},
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
      builder
        .addCase(getTopStoriesAsync.pending, (state) => {
          state.status = 'loading';
        })
        .addCase(getTopStoriesAsync.fulfilled, (state, action) => {
          state.status = 'succeeded';
          state.stories = action.payload;
        })
        .addCase(getTopStoriesAsync.rejected, (state, action) => {
            state.status = 'failed';
            state.stories = [];
            state.error = action.error.message || '';
          });
    },
  });
  
export default topStoriesSlice.reducer;
